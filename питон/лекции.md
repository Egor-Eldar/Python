# Python
                                    #Поколение Python
  **Вывод данных, команда Print**
  Внутри круглых скобок пишем то, что хотим вывести на экран. Если это текст, то ставим ковычки.
    !ПРИМЕР!
    print ("Мы изучаем язык Python")
    
  То, что мы пишем в круглых скобках у команды print называются аргументами или параметрами команд.

  команда "print" позволяет указывать несколько аргументов, в таком случае их надо отделять запятыми. Например, следующий код: print('Скоро я', 'буду программировать', 'на языке', 'Python')
  print('1', '2', '4', '8', '16')
  print('1, 2, 4, 8, 16')
При написании кода между аргумепнтами команды print после запятой мы ставим один символ "пробел". Это общепринятое правило Python. Оно не влияет на вывод данных.

  ПРИМЕЧАНИЕ! Команда print записывается только маленькими буквами и другое написание не допустимо, т.к. в Python строчные и заглавные буквы различны.
  ПРИМЕЧАНИЕ!! Каждая последующая команда print выводит набранный ртекст с новой строки.
  ПРИМЕЧАНИЕ!!! Команда print с пустым списком аргумента создаёт пустую строку.



print('Скоро я', 'буду программировать', 'на языке', 'Python')
print('1', '2', '4', '8', '16')
print('1 , 2 , 4 , 8 , 16')

https://drive.google.com/file/d/1W44vsQoKSMTV5HMY_GLi_WACF-Uxa02Q/view?usp=sharing

https://replit.com/@Egor-Eldar

https://replit.com/@Egor-Eldar/Python#main.py

13.09.2022

    ##Ввод данных. Команда imput

  Все пред. программы выдавали текст, известный в момент написания программного кода. Однако программы могут работать с данными, которые станут известны только во время выполнения программы. 

print('Как тебя зовут?')
name=input()
print('Привет,', name)

  Очень часто передж считыванием данных мы печатаем некоторый текст,чтобы пользователь, который вводит эти данные понимал, что именно от него требуется.

name=input("Как тебя зовут?")
print('Привет,', name)


Задание 1.
name=input()
print('Привет,', name)

Задание 2.

name=input()
print(name,'- чемпион!')

Задание 3

name1=input()
name2=input()
name3=input()
print(name1)
print(name2)
print(name3)

      ##sep,end, PEP 8

По умолчанию команда print принимает несколько аргументов, выводит ихь через один пробел, после чего ставит перевод строки. Это поведение можнго изменить, используя необязательные именованные параметры sep и end

print('A', 'B', 'C')
print('D', 'E', 'F')

print('a', 'b', 'c', sep='*')
print('d', 'e', 'f', sep='**')

Необязательный параметр sep команды print позволяет установить строку, с помощью которой будут разделены элементы при печати

    ###Параметр end
Если перевод строки делать не нужно или требуется указать специальное окончание, то следует явно указать значение для параментра end

print('a','b','c',end='@')
print('d','e','f',end='@@')

https://replit.com/@Egor-Eldar/Python#main.py





 a = int(input())
b = a % 10
c = a // 10
print('Число десятков =', c)
print('Число единиц =', b)

a = int(input())
b = a % 10
c = a // 10
print('Сумма цифр =', b + c)

a = int(input())
b = a % 10
c = a // 10
print(, b * 10 + c)

a = int(input())
b = a % 10
c = (a // 10) % 10
d = a // 100
print(d, c, b, sep=',')
 
a = int(input())
b = a % 10
c = (a % 100) // 10
d = a // 100
print('Сумма цифр =', b + c + d)

num1 = int(input())
a = num1 % 10
b = (num1 % 100) // 10
c = num1 // 100
print(b, a, c)
print(a, c, b)
print(c, a, b)
print(b, c, a)
print(c, b, a)
print(a, b, c)



                                                                     Работа с целыми числами
Все предыдущие программы которые мы писали,работали с текстовыми данными.Действительно,команда input() считывает строку текста. Однако во многих случаях нам нужно работать именно с числами.Чтобы в Phyton создать переменную целого типа данных,нужно опустить ковычки при обЪявлении переменной.Рассмотрим следующий код:

num1 = 7
num2 = 10
num3 = num1+num2

a=3
b=2
print(a+b)
print(a-b)
print(a/b)
print(a*b)



      Порядок выполнения операций в Phyton аналогичен порядку выполнению операций математики 
                             Приобразование типов
Приобразование строки к целому числу возможно с использованием команды int()
a ='1992'
year = int(s)

Таким образом мы переобразовываем из строкового типа данных в числовой

num1=int(input())
num2=int(input())
print(num + num2)

Для того чтобы считать одно целое число,мы пишем следующий код:
num = int(input())

Приобразование целого числа к строке возможно с использованием команды str() мы переобразовали целое число в строку и записали результат в переменную s. Таким образом,переменная num имеет целочисленный тип данных.
  
   ***Примичание***
1.При работе с целочисленными переменными, часто нужно осуществлять присвоение значению переменной целой математической формулы:
<Имя переменной> = <математическая формула>

2.Cокращение int происходит от английского integer - целый
3.В большенстве языков программирования переменная целого типа имеет ограничение.В Phyton реализованно так называемое длинная арифметика,то есть,переменная целого типа не имеет ограничений
4.Минус может использоваться для обозначения отрицательных чисел.А вот +,/,* всегда стоят между 2 переменными
num1 = -6   #унарный минус
num2 = 17-7 #бинарный минус
   22.09.2022
                                                                 **Модульная математика в Питон.**
   Дополнительные операции  - Возведение в степень. %- Остаток от делания. //-Целочисленное дело. Возведение в сиепень. Оператор возводит в степень a n возводит число a в степень n. Оператор возникновения в степени  может возводиться не только в положительную степень, но и в отрицательную. Аналогично, основание степени a также может быть числом отрицательным. Оператор вычисления в степени ( ) является правоассоциативным (значение вычисления вычисляется налево) в соответствии с выбором математики. Таким образом, выражение x  y  z вычесляется как x  (y  z). Целочисленное дело Для положительных чисел оператор целочисленного деления ведёт как обычное деление, за исключительных, что он отбрасывает одну десятичную часть результата. При этом необходимо помнить, что результат целочисленного деления не превосходит частное. Другими словами, округление берётся в меньшую сторону (число −4 меньше, чем число −3). Деление с остатком Оператор деления с остатком возвращает обратно от деления двух значений чисел. Примечание Примечание1. Оператор нахождения остатка очень полезен при решении многих задач. Операторы // и % имеют такой же приоритет, как и операторы умножения и обычного деления. Примечание3. Наивысший приоритет имеет оператор связи в степени  . Алгоритм получения n-го числа

    ##Условный оператор if-else

  Программы должны уметь выполнять разные действия в зависимости от введенных данных. Для принятия решения программа проверяет, истинно или ложно определенное условие.
  В Python существует несколько способов проверки, и в каждом случае возможны два исхода: истина (True) или ложь (False).
  Проверка условий и принятие решений по результатам этой проверки называется ветвлением (branching). Программа таким способом выбирает, по какой из возможных ветвей ей двигаться дальше.
В Python проверка условия осуществляется при помощи ключевого слова if.

  Рассмотрим следующую программу:
  
    answer = input('Какой язык программирования мы изучаем?')
    if answer == 'Python':
        print('Верно! Мы ботаем Python =)')
        print('Python - отличный язык!')
  Программа просит пользователя ввести текст и проверяет результат ввода. Если введенный текст равен строке «Python», то выводит пользователю текст:
    Верно! Мы ботаем Python =)
     Python - отличный язык!

  Двоеточие (:) в конце строки с инструкцией if сообщает интерпретатору Python, что дальше находится блок команд. В блок команд входят все строки с отступом под строкой с инструкцией if, вплоть до следующей строки без отступа.
  Если условие истинно, выполняется весь расположенный ниже блок. В предыдущем примере блок инструкций составляет третья и четвёртая строки программы.
  Блоком кода называют объединённые друг с другом строки. Они всегда связаны с определённой частью программы (например, с инструкцией if). В Python блоки кода формируются при помощи отступов.

  Предыдущая программа выводит текст в случае, если условие истинно. Но если условие ложно, то программа ничего не выводит. Для того, чтобы обеспечить возможность выполнять что-либо, если условие оказалось ложным, мы используем ключевое слово else.
    answer = input('Какой язык программирования мы изучаем?')
    if answer == 'Python':
       print('Верно! Мы ботаем Python =)')
       print('Python - отличный язык!')
    else: print('Не совсем так!')



  В новой программе мы обрабатываем сразу два случая:
    - если условие истинно (пользователь ввел «Python»), 
    - если условие ложно (пользователь ввел что угодно, кроме «Python»).

    ##Отступы
  В некоторых языках программирования отступы — дело личного вкуса, и можно вообще обходиться без них. Однако в Python они неотъемлемая часть кода. Именно отступ сообщает интерпретатору Python, где начинается и где заканчивается блок кода.
  **Отступ** — небольшое смещение строки кода вправо. В начале такой строки находятся пробелы, и поэтому она на несколько символов отстоит от левого края.
Некоторым инструкциям в Python (например, инструкции if) именно блок кода сообщает, какие действия следует предпринять. После if блок кода информирует интерпретатор Python, как действовать, если условие истинно, и как — если оно ложно.

    ##Операторы сравнения
  Можно заметить, что в проверке условия мы использовали двойное равенство (==), вместо ожидаемого одиночного (=). Не стоит путать оператор присваивания (=) с условным оператором (==).

  Оператор присваивания (=) присваивает переменным значения:
    num = 1992
    s = 'I love Python'

  Для проверки двух элементов на равенство Python использует удвоенный знак равно (==). Вот так:
    if answer == 'Python':
    if name == 'Gvido':
    if temperature == 40:

  Путаница с операторами == и = является одной из самых распространенных ошибок в программировании. Эти символы используются не только в Python, и каждый день множество программистов используют их неправильно.

unnamed
![таблица](unnamed.png "Таблица")

num1 = int(input())
num2 = int(input())

if num1 < num2:
print(num1, 'меньше чем', num2)
if num1 > num2:
    print(num1, 'больше чем', num2)
if num1 == num2:       # используем двойное равенство
    print(num1, 'равно', num2)
if num1 != num2:
    print(num1, 'не равно', num2)

    ##Цепочки сравнений
  Операторы сравнения в Python можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки), например, a == b == c или 1 <= x <= 10. Следующий код проверяет, находится ли значение переменной age в диапазоне от 3 до 6:

age = int(input())
if 3 <= age <= 6:
    print('Вы ребёнок')

  Код, проверяющий равенство трех переменных, может выглядеть так:

if a == b == c:
    print('числа равны')
else:
    print('числа не равны')

    ##Транзитивность
  Операция равенства является транзитивной. Это означает, что если a == b и b == c, то из этого следует, что a == c. Именно поэтому предыдущий код, проверяющий равенство трёх переменных, работает как полагается. 
Из курса математики вам могут быть знакомы другие примеры транзитивных операций:

  **Отношение порядка:** если a > b и b > c, то a > c;
  **Параллельность прямых:** если a || b и b || c, то a || c
  **Делимость:** если a делится на b и b делится на c, то a делится c.
  
  Наглядно транзитивность отношения порядка можно понять на таком примере: если сосед слева старше вас  (a>b), а вы старше соседа справа  (b>c), то сосед слева точно старше соседа справа (a>c).
  Операция неравенства (!=), в отличие от операции равенства (==), является нетранзитивной. То есть из того, что a != b и b != c,вовсе не следует, что a != c. Действительно, если вас зовут не так, как соседа слева и не так, как соседа справа, то нет гарантии, что у обоих соседей не окажутся одинаковые имена.

  Таким образом, следующий код вовсе не проверяет тот факт, что все три переменные различны:
if a != b != c:
    print('числа не равны')
else:
print('числа равны')

!!!ЗАДАНИЯ!!!
word = input()
if word == 'Python':
    print('ДА')
else:
   print('НЕТ')
   

num = int(input())
last_digit = num % 10    # последняя цифра числа
first_digit = num // 10  # первая цифра числа
if last_digit == first_digit:
    print('ДА')
else:
   print('НЕТ')

num1, num2, num3 = int(input()), int(input()), int(input())
counter = 0  # переменная счётчик
if num1 % 2 == 0:
    counter = counter + 1  # увеличиваем счётчик на 1
if num2 % 2 == 0:
    counter = counter + 1  # увеличиваем счётчик на 1
if num3 % 2 == 0:
    counter = counter + 1  # увеличиваем счётчик на 1
print(counter)

 answer = input('Подтверждение пароля')
    if answer == 'qwerty':
       print('Пароль принят')
    else: print('Пароль не принят')


a = int(input('n'))
print('четное' if a % 2 == 0 else 'не четное')

n = int(input())
print('ДА' if n // 1000 % 10 + n % 10 == n // 100 % 10 - n // 10 % 10 else 'НЕТ')

n=int(input())
print('Доступ разрешён' if n >= 18 else 'Доступ запрещён')

a= int(input())
b= int(input()) 
c= int(input())
print('YES' if (c - b) == (b - a) and (a <= b <= c or a > b > c) else 'NO')

      #Вложенный оператор
  Внутри условного оператора можно использовать любые инструкции языка Python, в том числе и условный оператор. Получаем вложенное ветвление: после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные блоки имеют больший размер отступа (+4 пробела для каждого следующего уровня).

  Мы разбирали задачу об определении координатной четверти точки. Программу можно переписать с использованием вложенного оператора:

x = int(input())
y = int(input())
if x > 0:
    if y > 0:
        print('Первая четверть')
    else:
        print('Четвертая четверть')
else:
    if y > 0:
        print('Вторая четверть')
    else:
        print('Третья четверть')

  В данном случае уровень вложенности равен двум, так что программа одинаково хорошо читается как с помощью использования логического оператора and, так и с помощью вложенного оператора.
  Рассмотрим программу, которая переводит стобалльную оценку в пятибалльную. Для её реализации нужно воспользоваться вложенным условным оператором:

grade = int(input('Введите вашу отметку по 100-балльной системе: '))
if grade >= 90:
    print(5)
else:
    if grade >= 80:
        print(4)
    else:
        if grade >= 70: 
            print(3)
        else:
            if grade >= 60:
                print(2)
            else:
                print(1)

  В этом примере уровень вложенности настолько глубок, что код становится трудно понять.
  Выбор из нескольких альтернатив – это обычное дело, здесь имеет смысл избегать глубокого вложения. Для этого в Python есть каскадный условный оператор.

  Каскадный условный оператор

  Если требуется проверить несколько условий, в языке Python используется каскадный условный оператор.
        Синтаксис каскадного условного оператора имеет следующий вид:

if условие1:
    блок кода
elif условие2:
    блок кода
...
else:
    блок кода

  При исполнении такого условного оператора сначала проверяется условие 1. Если оно является истинным, то исполняется блок кода, который следует сразу после него, вплоть до выражения elif. Остальная часть конструкции игнорируется. Однако если условие 1 является ложным, то программа перескакивает непосредственно к следующему выражению elif и проверяет условие 2. Если оно истинное, то исполняется блок кода, который следует сразу после него, вплоть до следующего выражения elif. И остальная часть условного оператора тогда игнорируется. Этот процесс продолжается до тех пор, пока не будет найдено условие, которое является истинным, либо пока больше не останется выражений elif. Если ни одно условие не является истинным, то исполняется блок кода после выражения else.

  Приведенный ниже фрагмент кода является примером каскадного условного оператора  if-elif-else. Этот фрагмент кода работает так же, как предыдущий код, использующий вложенный условный оператор. 

grade = int(input('Введите вашу отметку: '))
if grade >= 90:
    print(5)
elif grade >= 80:
    print(4)
elif grade >= 70:
    print(3)
elif grade >= 60:
    print(2)
else:
    print(1)

  Обратите внимание на выравнивание и выделение отступом, которые применены в инструкции if-elif-else: выражения if, elif и else выровнены и исполняемые по условию блоки выделены отступом.

  Инструкция if-elif-else не является обязательной, потому что ее логика может быть запрограммирована вложенными инструкциями if-else. Однако длинная серия вложенных инструкций if-else имеет два характерных недостатка:
  * программный код может стать сложным и трудным для восприятия; 
  * из-за необходимого выделения отступом продолжительная серия вложенных инструкций if-else может стать слишком длинной, чтобы целиком уместиться на экране монитора без горизонтальной прокрутки.
  Логика инструкции if-elif-else обычно прослеживается легче, чем длинная серия вложенных инструкций if-else. И поскольку в инструкции if-elif-else все выражения выровнены, длина строк в данной инструкции, как правило, короче. 

  Решение задач
  Задача 1. Даны три целых числа. Определите, сколько среди них совпадающих. Программа должна вывести одно из чисел: 3 (если все совпадают), 2 (если два совпадает) или 0 (если все числа различны).
Решение. Программа, решающая поставленную задачу, может иметь следующий вид:
  
  1 способ. Использование вложенного условного оператора.
a, b, c = int(input()), int(input()), int(input())
if a == b:
    if b == c:
        print(3)
    else:
        print(2)
else:
    if a == c:
        print(2)
    else:
        if b == c:
            print(2)
        else:
            print(0)

  2 способ. Использование каскадного условного оператора.
a, b, c = int(input()), int(input()), int(input())
if a == b == c:
    print(3)
elif a == b != c:
    print(2)
elif a != b == c:
    print(2)
elif a == c != b:
    print(2)
else:
    print(0)

  3 способ. Использование каскадного условного оператора и логического оператора or.
a, b, c = int(input()), int(input()), int(input())
if a == b == c:
    print(3)
elif a == b != c or a != b == c or a == c != b:
    print(2)
else:
    print(0)




https://colab.research.google.com/drive/1gPj6SjTdCkMAbKi9HfvZS7x6qLVLaAqn?usp=sharing

Переобразование строки в целое число Для преобразования строки в целое число мы используем команду int(): num = int(input()) **#преобразование считанной строки в целое число.

Для преобразования строки в целое число не обязательно использовать команду input(()) Следующий код преобразует строку 12345 в целое число: n = int('12345') Язык Python предоставляет 4 арифметических опертаора для работы с целыми числами (+,+,/,), а также три дополнительных(%для остатка,// для целочисленного деления и ** для возведения в степень)** total =a + b diff = a - b prod = a * b div1 = a \ b div2 = a \ b mod = a % b exp = a ** b Числа с плавающей точкой Наравне с целыми числами в Python есть возможность работы с дробными(вещественными) числами.Так,например,числа 2\3,корень 2,пи - являются вещественными и целого типа int недостаточно для их представления. Дробные числа в информатике называют числами с плавающей точкой. В Python используется тип данных float. В отличие от математики в информатике для разделения целой и дробной части используется точка. num = float(input()) #преобразование считанной строки в число сс плавающей точкой Модули В Python есть множество разнообразных функций, которые уже реализованны и готовы к использованию. Такие функции упакованы в модули и называются библиотека функций. Модуль math Модуль Math - один из важнейших в Python. Предстовляет обширный функционал для проведения вычислений с вещественными числами(числами с плавающей точкой). Если необходимо подключить модуль math пользуются командой input import math *from math import ** image image image

Цикл for Одно из преимуществ компьютеров перед людьми - способность повторять одини и те же действия многократно,быстро и совсем не утомляясь. В Python существует две основных разновидности циклов:

циклы, повторяющиеся определенное количество раз (for, счетные циклы, counting loops); циклы, повторяющиеся до наступления определенного события (while, условные циклы, conditional loops). Цикл for замечательно работает, если мы заранее знаем, сколько повторений (итераций) нам требуется сделать.

Рассмотрим код, который распечатает 10 раз слово "Привет": for i in range(10): print('Привет')

Структура цикла for в Python выглядит так:

for название_переменной_цикла in range(количество повторений): блок кода

Двоеточие (:) в конце строки с инструкцией for сообщает интерпретатору Python, что дальше находится блок команд. В блок команд входят все строки, расположенные с отступом от строки с инструкцией for, вплоть до следующей строки без отступа.

Такая программа считывает 5 чисел и выводит на экран их квадраты вместе с поясняющей надписью. Поскольку вторая и третья строки выделены отступом, Python считает, что это тело цикла, которое выполняется 5 раз. Четвертая строка не содержит отступа, поэтому не является частью цикла и будет выполнена всего один раз, после того как цикл завершится. print('A') print('B') for i in range(5): print('C') for i in range(10): print('D') print('E')

Переменная цикла Рассмотрим для чего нужна и как работает переменная цикла i for i in range(10)

как видно из кода в Python начинается с 0 поскольку переменная цикла i увеличивается каждый раз,то ее можно использовать для отслеживания номери итерации на которой мы находимся в циклическом процессе

for i in range(10) print (i+1,'--Привет--') Имена переменных циклов Ранее говорилось, что имена переменных должны носить осмысленный характер и описывать их назначение. Однако для переменных цикла иногда делается исключения. В программировании для переменных цикла обычно используют буквы i, j, k. Бывают ситуации когда переменная цикла не используется в теле цикла. В таком случае, вместо того, чтобы давать ей имя, мы можем указать символ нижнего подчеркивания _ : for _ in range(5) print ('Python-awesome') Функция range() начение, которое мы указываем в скобках у функции range() обозначает количество итераций цикла, при этом переменная i принимает последовательно значения: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Если быть более точным, то мы говорим, что функция range(n) генерирует последовательность чисел от 0 до n-1, а цикл for последовательно перебирает эту последовательность. Перегрузка range() с двумя параметрами Если мы хотим начинать последовательность не с 0, а с какого-то другого числа, то мы можем использовать перегрузку функции range() принимающую два параметра. Например, вызов функции range(1, 5) сгенерирует последовательность чисел 1, 2, 3, 4 (будьте внимательны, правая граница не включительно). Если нам нужны числа от 1 до 5 включительно, то мы используем range(1, 6). Таким образом:

  * range(n): создает последовательность чисел 0, 1, 2, 3, ..., n - 1;
  * range(n, m): создает последовательность чисел n, n + 1, n + 2, ..., m - 2, m - 1. 

Напишем программу, которая выводит те числа из промежутка [100;999], которые оканчиваются на 7. Используя функцию range() с двумя параметрами, получаем: for i in range(100,1000): # перебираем числа от 100 до 999 if i % 10==7: #используем остаток от деления на 10,для получения последней цифры print(i) Перегрузка range() с 3 параметрами Передавая два параметра в функцию range() мы можем генерировать любую последовательность целых чисел с шагом 1. Но, что делать если нужно поменять шаг? Как быть если мы хотим сгенерировать последовательность чисел 5, 10, 15, 20, 25? В этом случае существует еще одна перегрузка функции range(), принимающая три параметра: range(n, m, k). Первый параметр задает старт последовательности, второй параметр задает стоп последовательности и третий – шаг генерации чисел.
Например, вызов функции range(1, 10, 2) создаст последовательность чисел 1, 3, 5, 7, 9, а вызов функции range(5, 30, 5) сгенерирует последовательность 5, 10, 15, 20, 25. Напишем программу, которая выводит все четные числа из промежутка [56;170].

Используя функцию range() с тремя параметрами, получаем:
![image](https://user-images.githubusercontent.com/112847166/197638919-f9a51d47-d697-4fe0-9513-b8c9db2b2e29.png)
 Отрицательный шаг генерации Если шаг генерации является положительным числом, то генерируемая последовательность будет возрастать. Мы можем указать отрицательный шаг генерации (третий параметр), что приведет к генерированию убывающей последовательности.

В случае отрицательного шага, мы должны гарантировать, что старт последовательности (первый параметр) больше чем конец последовательности (второй параметр).

Например, вызов функции range(20, 16, -1) создаст последовательность чисел 20, 19, 18, 17, а вызов функции range(20, 10, -3) сгенерирует последовательность 20, 17, 14, 11.

Напишем программу, которая отсчитывает от 5 до 1, а затем выводит текст "Взлетаем!!!"
![image](https://user-images.githubusercontent.com/112847166/197638864-15a3e152-3506-409e-a380-95edae54525f.png)














































