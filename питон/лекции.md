# Python
                                    #Поколение Python
  **Вывод данных, команда Print**
  Внутри круглых скобок пишем то, что хотим вывести на экран. Если это текст, то ставим ковычки.
    !ПРИМЕР!
    print ("Мы изучаем язык Python")
    
  То, что мы пишем в круглых скобках у команды print называются аргументами или параметрами команд.

  команда "print" позволяет указывать несколько аргументов, в таком случае их надо отделять запятыми. Например, следующий код: print('Скоро я', 'буду программировать', 'на языке', 'Python')
  print('1', '2', '4', '8', '16')
  print('1, 2, 4, 8, 16')
При написании кода между аргумепнтами команды print после запятой мы ставим один символ "пробел". Это общепринятое правило Python. Оно не влияет на вывод данных.

  ПРИМЕЧАНИЕ! Команда print записывается только маленькими буквами и другое написание не допустимо, т.к. в Python строчные и заглавные буквы различны.
  ПРИМЕЧАНИЕ!! Каждая последующая команда print выводит набранный ртекст с новой строки.
  ПРИМЕЧАНИЕ!!! Команда print с пустым списком аргумента создаёт пустую строку.



print('Скоро я', 'буду программировать', 'на языке', 'Python')
print('1', '2', '4', '8', '16')
print('1 , 2 , 4 , 8 , 16')

https://drive.google.com/file/d/1W44vsQoKSMTV5HMY_GLi_WACF-Uxa02Q/view?usp=sharing

https://replit.com/@Egor-Eldar

https://replit.com/@Egor-Eldar/Python#main.py

13.09.2022

    ##Ввод данных. Команда imput

  Все пред. программы выдавали текст, известный в момент написания программного кода. Однако программы могут работать с данными, которые станут известны только во время выполнения программы. 

print('Как тебя зовут?')
name=input()
print('Привет,', name)

  Очень часто передж считыванием данных мы печатаем некоторый текст,чтобы пользователь, который вводит эти данные понимал, что именно от него требуется.

name=input("Как тебя зовут?")
print('Привет,', name)


Задание 1.
name=input()
print('Привет,', name)

Задание 2.

name=input()
print(name,'- чемпион!')

Задание 3

name1=input()
name2=input()
name3=input()
print(name1)
print(name2)
print(name3)

      ##sep,end, PEP 8

По умолчанию команда print принимает несколько аргументов, выводит ихь через один пробел, после чего ставит перевод строки. Это поведение можнго изменить, используя необязательные именованные параметры sep и end

print('A', 'B', 'C')
print('D', 'E', 'F')

print('a', 'b', 'c', sep='*')
print('d', 'e', 'f', sep='**')

Необязательный параметр sep команды print позволяет установить строку, с помощью которой будут разделены элементы при печати

    ###Параметр end
Если перевод строки делать не нужно или требуется указать специальное окончание, то следует явно указать значение для параментра end

print('a','b','c',end='@')
print('d','e','f',end='@@')

https://replit.com/@Egor-Eldar/Python#main.py





 a = int(input())
b = a % 10
c = a // 10
print('Число десятков =', c)
print('Число единиц =', b)

a = int(input())
b = a % 10
c = a // 10
print('Сумма цифр =', b + c)

a = int(input())
b = a % 10
c = a // 10
print(, b * 10 + c)

a = int(input())
b = a % 10
c = (a // 10) % 10
d = a // 100
print(d, c, b, sep=',')
 
a = int(input())
b = a % 10
c = (a % 100) // 10
d = a // 100
print('Сумма цифр =', b + c + d)

num1 = int(input())
a = num1 % 10
b = (num1 % 100) // 10
c = num1 // 100
print(b, a, c)
print(a, c, b)
print(c, a, b)
print(b, c, a)
print(c, b, a)
print(a, b, c)



                                                                     Работа с целыми числами
Все предыдущие программы которые мы писали,работали с текстовыми данными.Действительно,команда input() считывает строку текста. Однако во многих случаях нам нужно работать именно с числами.Чтобы в Phyton создать переменную целого типа данных,нужно опустить ковычки при обЪявлении переменной.Рассмотрим следующий код:

num1 = 7
num2 = 10
num3 = num1+num2

a=3
b=2
print(a+b)
print(a-b)
print(a/b)
print(a*b)



      Порядок выполнения операций в Phyton аналогичен порядку выполнению операций математики 
                             Приобразование типов
Приобразование строки к целому числу возможно с использованием команды int()
a ='1992'
year = int(s)

Таким образом мы переобразовываем из строкового типа данных в числовой

num1=int(input())
num2=int(input())
print(num + num2)

Для того чтобы считать одно целое число,мы пишем следующий код:
num = int(input())

Приобразование целого числа к строке возможно с использованием команды str() мы переобразовали целое число в строку и записали результат в переменную s. Таким образом,переменная num имеет целочисленный тип данных.
  
   ***Примичание***
1.При работе с целочисленными переменными, часто нужно осуществлять присвоение значению переменной целой математической формулы:
<Имя переменной> = <математическая формула>

2.Cокращение int происходит от английского integer - целый
3.В большенстве языков программирования переменная целого типа имеет ограничение.В Phyton реализованно так называемое длинная арифметика,то есть,переменная целого типа не имеет ограничений
4.Минус может использоваться для обозначения отрицательных чисел.А вот +,/,* всегда стоят между 2 переменными
num1 = -6   #унарный минус
num2 = 17-7 #бинарный минус
   22.09.2022
                                                                 **Модульная математика в Питон.**
   Дополнительные операции  - Возведение в степень. %- Остаток от делания. //-Целочисленное дело. Возведение в сиепень. Оператор возводит в степень a n возводит число a в степень n. Оператор возникновения в степени  может возводиться не только в положительную степень, но и в отрицательную. Аналогично, основание степени a также может быть числом отрицательным. Оператор вычисления в степени ( ) является правоассоциативным (значение вычисления вычисляется налево) в соответствии с выбором математики. Таким образом, выражение x  y  z вычесляется как x  (y  z). Целочисленное дело Для положительных чисел оператор целочисленного деления ведёт как обычное деление, за исключительных, что он отбрасывает одну десятичную часть результата. При этом необходимо помнить, что результат целочисленного деления не превосходит частное. Другими словами, округление берётся в меньшую сторону (число −4 меньше, чем число −3). Деление с остатком Оператор деления с остатком возвращает обратно от деления двух значений чисел. Примечание Примечание1. Оператор нахождения остатка очень полезен при решении многих задач. Операторы // и % имеют такой же приоритет, как и операторы умножения и обычного деления. Примечание3. Наивысший приоритет имеет оператор связи в степени  . Алгоритм получения n-го числа

    ##Условный оператор if-else

  Программы должны уметь выполнять разные действия в зависимости от введенных данных. Для принятия решения программа проверяет, истинно или ложно определенное условие.
  В Python существует несколько способов проверки, и в каждом случае возможны два исхода: истина (True) или ложь (False).
  Проверка условий и принятие решений по результатам этой проверки называется ветвлением (branching). Программа таким способом выбирает, по какой из возможных ветвей ей двигаться дальше.
В Python проверка условия осуществляется при помощи ключевого слова if.

  Рассмотрим следующую программу:
  
    answer = input('Какой язык программирования мы изучаем?')
    if answer == 'Python':
        print('Верно! Мы ботаем Python =)')
        print('Python - отличный язык!')
  Программа просит пользователя ввести текст и проверяет результат ввода. Если введенный текст равен строке «Python», то выводит пользователю текст:
    Верно! Мы ботаем Python =)
     Python - отличный язык!

  Двоеточие (:) в конце строки с инструкцией if сообщает интерпретатору Python, что дальше находится блок команд. В блок команд входят все строки с отступом под строкой с инструкцией if, вплоть до следующей строки без отступа.
  Если условие истинно, выполняется весь расположенный ниже блок. В предыдущем примере блок инструкций составляет третья и четвёртая строки программы.
  Блоком кода называют объединённые друг с другом строки. Они всегда связаны с определённой частью программы (например, с инструкцией if). В Python блоки кода формируются при помощи отступов.

  Предыдущая программа выводит текст в случае, если условие истинно. Но если условие ложно, то программа ничего не выводит. Для того, чтобы обеспечить возможность выполнять что-либо, если условие оказалось ложным, мы используем ключевое слово else.
    answer = input('Какой язык программирования мы изучаем?')
    if answer == 'Python':
       print('Верно! Мы ботаем Python =)')
       print('Python - отличный язык!')
    else: print('Не совсем так!')



  В новой программе мы обрабатываем сразу два случая:
    - если условие истинно (пользователь ввел «Python»), 
    - если условие ложно (пользователь ввел что угодно, кроме «Python»).

    ##Отступы
  В некоторых языках программирования отступы — дело личного вкуса, и можно вообще обходиться без них. Однако в Python они неотъемлемая часть кода. Именно отступ сообщает интерпретатору Python, где начинается и где заканчивается блок кода.
  **Отступ** — небольшое смещение строки кода вправо. В начале такой строки находятся пробелы, и поэтому она на несколько символов отстоит от левого края.
Некоторым инструкциям в Python (например, инструкции if) именно блок кода сообщает, какие действия следует предпринять. После if блок кода информирует интерпретатор Python, как действовать, если условие истинно, и как — если оно ложно.

    ##Операторы сравнения
  Можно заметить, что в проверке условия мы использовали двойное равенство (==), вместо ожидаемого одиночного (=). Не стоит путать оператор присваивания (=) с условным оператором (==).

  Оператор присваивания (=) присваивает переменным значения:
    num = 1992
    s = 'I love Python'

  Для проверки двух элементов на равенство Python использует удвоенный знак равно (==). Вот так:
    if answer == 'Python':
    if name == 'Gvido':
    if temperature == 40:

  Путаница с операторами == и = является одной из самых распространенных ошибок в программировании. Эти символы используются не только в Python, и каждый день множество программистов используют их неправильно.

unnamed
![таблица](unnamed.png "Таблица")

num1 = int(input())
num2 = int(input())

if num1 < num2:
print(num1, 'меньше чем', num2)
if num1 > num2:
    print(num1, 'больше чем', num2)
if num1 == num2:       # используем двойное равенство
    print(num1, 'равно', num2)
if num1 != num2:
    print(num1, 'не равно', num2)

    ##Цепочки сравнений
  Операторы сравнения в Python можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки), например, a == b == c или 1 <= x <= 10. Следующий код проверяет, находится ли значение переменной age в диапазоне от 3 до 6:

age = int(input())
if 3 <= age <= 6:
    print('Вы ребёнок')

  Код, проверяющий равенство трех переменных, может выглядеть так:

if a == b == c:
    print('числа равны')
else:
    print('числа не равны')

    ##Транзитивность
  Операция равенства является транзитивной. Это означает, что если a == b и b == c, то из этого следует, что a == c. Именно поэтому предыдущий код, проверяющий равенство трёх переменных, работает как полагается. 
Из курса математики вам могут быть знакомы другие примеры транзитивных операций:

  **Отношение порядка:** если a > b и b > c, то a > c;
  **Параллельность прямых:** если a || b и b || c, то a || c
  **Делимость:** если a делится на b и b делится на c, то a делится c.
  
  Наглядно транзитивность отношения порядка можно понять на таком примере: если сосед слева старше вас  (a>b), а вы старше соседа справа  (b>c), то сосед слева точно старше соседа справа (a>c).
  Операция неравенства (!=), в отличие от операции равенства (==), является нетранзитивной. То есть из того, что a != b и b != c,вовсе не следует, что a != c. Действительно, если вас зовут не так, как соседа слева и не так, как соседа справа, то нет гарантии, что у обоих соседей не окажутся одинаковые имена.

  Таким образом, следующий код вовсе не проверяет тот факт, что все три переменные различны:
if a != b != c:
    print('числа не равны')
else:
print('числа равны')

!!!ЗАДАНИЯ!!!
word = input()
if word == 'Python':
    print('ДА')
else:
   print('НЕТ')
   

num = int(input())
last_digit = num % 10    # последняя цифра числа
first_digit = num // 10  # первая цифра числа
if last_digit == first_digit:
    print('ДА')
else:
   print('НЕТ')

num1, num2, num3 = int(input()), int(input()), int(input())
counter = 0  # переменная счётчик
if num1 % 2 == 0:
    counter = counter + 1  # увеличиваем счётчик на 1
if num2 % 2 == 0:
    counter = counter + 1  # увеличиваем счётчик на 1
if num3 % 2 == 0:
    counter = counter + 1  # увеличиваем счётчик на 1
print(counter)

 answer = input('Подтверждение пароля')
    if answer == 'qwerty':
       print('Пароль принят')
    else: print('Пароль не принят')


a = int(input('n'))
print('четное' if a % 2 == 0 else 'не четное')

n = int(input())
print('ДА' if n // 1000 % 10 + n % 10 == n // 100 % 10 - n // 10 % 10 else 'НЕТ')

n=int(input())
print('Доступ разрешён' if n >= 18 else 'Доступ запрещён')

a= int(input())
b= int(input()) 
c= int(input())
print('YES' if (c - b) == (b - a) and (a <= b <= c or a > b > c) else 'NO')

      #Вложенный оператор
  Внутри условного оператора можно использовать любые инструкции языка Python, в том числе и условный оператор. Получаем вложенное ветвление: после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные блоки имеют больший размер отступа (+4 пробела для каждого следующего уровня).

  Мы разбирали задачу об определении координатной четверти точки. Программу можно переписать с использованием вложенного оператора:

x = int(input())
y = int(input())
if x > 0:
    if y > 0:
        print('Первая четверть')
    else:
        print('Четвертая четверть')
else:
    if y > 0:
        print('Вторая четверть')
    else:
        print('Третья четверть')

  В данном случае уровень вложенности равен двум, так что программа одинаково хорошо читается как с помощью использования логического оператора and, так и с помощью вложенного оператора.
  Рассмотрим программу, которая переводит стобалльную оценку в пятибалльную. Для её реализации нужно воспользоваться вложенным условным оператором:

grade = int(input('Введите вашу отметку по 100-балльной системе: '))
if grade >= 90:
    print(5)
else:
    if grade >= 80:
        print(4)
    else:
        if grade >= 70: 
            print(3)
        else:
            if grade >= 60:
                print(2)
            else:
                print(1)

  В этом примере уровень вложенности настолько глубок, что код становится трудно понять.
  Выбор из нескольких альтернатив – это обычное дело, здесь имеет смысл избегать глубокого вложения. Для этого в Python есть каскадный условный оператор.

  Каскадный условный оператор

  Если требуется проверить несколько условий, в языке Python используется каскадный условный оператор.
        Синтаксис каскадного условного оператора имеет следующий вид:

if условие1:
    блок кода
elif условие2:
    блок кода
...
else:
    блок кода

  При исполнении такого условного оператора сначала проверяется условие 1. Если оно является истинным, то исполняется блок кода, который следует сразу после него, вплоть до выражения elif. Остальная часть конструкции игнорируется. Однако если условие 1 является ложным, то программа перескакивает непосредственно к следующему выражению elif и проверяет условие 2. Если оно истинное, то исполняется блок кода, который следует сразу после него, вплоть до следующего выражения elif. И остальная часть условного оператора тогда игнорируется. Этот процесс продолжается до тех пор, пока не будет найдено условие, которое является истинным, либо пока больше не останется выражений elif. Если ни одно условие не является истинным, то исполняется блок кода после выражения else.

  Приведенный ниже фрагмент кода является примером каскадного условного оператора  if-elif-else. Этот фрагмент кода работает так же, как предыдущий код, использующий вложенный условный оператор. 

grade = int(input('Введите вашу отметку: '))
if grade >= 90:
    print(5)
elif grade >= 80:
    print(4)
elif grade >= 70:
    print(3)
elif grade >= 60:
    print(2)
else:
    print(1)

  Обратите внимание на выравнивание и выделение отступом, которые применены в инструкции if-elif-else: выражения if, elif и else выровнены и исполняемые по условию блоки выделены отступом.

  Инструкция if-elif-else не является обязательной, потому что ее логика может быть запрограммирована вложенными инструкциями if-else. Однако длинная серия вложенных инструкций if-else имеет два характерных недостатка:
  * программный код может стать сложным и трудным для восприятия; 
  * из-за необходимого выделения отступом продолжительная серия вложенных инструкций if-else может стать слишком длинной, чтобы целиком уместиться на экране монитора без горизонтальной прокрутки.
  Логика инструкции if-elif-else обычно прослеживается легче, чем длинная серия вложенных инструкций if-else. И поскольку в инструкции if-elif-else все выражения выровнены, длина строк в данной инструкции, как правило, короче. 

  Решение задач
  Задача 1. Даны три целых числа. Определите, сколько среди них совпадающих. Программа должна вывести одно из чисел: 3 (если все совпадают), 2 (если два совпадает) или 0 (если все числа различны).
Решение. Программа, решающая поставленную задачу, может иметь следующий вид:
  
  1 способ. Использование вложенного условного оператора.
a, b, c = int(input()), int(input()), int(input())
if a == b:
    if b == c:
        print(3)
    else:
        print(2)
else:
    if a == c:
        print(2)
    else:
        if b == c:
            print(2)
        else:
            print(0)

  2 способ. Использование каскадного условного оператора.
a, b, c = int(input()), int(input()), int(input())
if a == b == c:
    print(3)
elif a == b != c:
    print(2)
elif a != b == c:
    print(2)
elif a == c != b:
    print(2)
else:
    print(0)

  3 способ. Использование каскадного условного оператора и логического оператора or.
a, b, c = int(input()), int(input()), int(input())
if a == b == c:
    print(3)
elif a == b != c or a != b == c or a == c != b:
    print(2)
else:
    print(0)




https://colab.research.google.com/drive/1gPj6SjTdCkMAbKi9HfvZS7x6qLVLaAqn?usp=sharing

Переобразование строки в целое число Для преобразования строки в целое число мы используем команду int(): num = int(input()) **#преобразование считанной строки в целое число.

Для преобразования строки в целое число не обязательно использовать команду input(()) Следующий код преобразует строку 12345 в целое число: n = int('12345') Язык Python предоставляет 4 арифметических опертаора для работы с целыми числами (+,+,/,), а также три дополнительных(%для остатка,// для целочисленного деления и ** для возведения в степень)** total =a + b diff = a - b prod = a * b div1 = a \ b div2 = a \ b mod = a % b exp = a ** b Числа с плавающей точкой Наравне с целыми числами в Python есть возможность работы с дробными(вещественными) числами.Так,например,числа 2\3,корень 2,пи - являются вещественными и целого типа int недостаточно для их представления. Дробные числа в информатике называют числами с плавающей точкой. В Python используется тип данных float. В отличие от математики в информатике для разделения целой и дробной части используется точка. num = float(input()) #преобразование считанной строки в число сс плавающей точкой Модули В Python есть множество разнообразных функций, которые уже реализованны и готовы к использованию. Такие функции упакованы в модули и называются библиотека функций. Модуль math Модуль Math - один из важнейших в Python. Предстовляет обширный функционал для проведения вычислений с вещественными числами(числами с плавающей точкой). Если необходимо подключить модуль math пользуются командой input import math *from math import ** image image image

Цикл for Одно из преимуществ компьютеров перед людьми - способность повторять одини и те же действия многократно,быстро и совсем не утомляясь. В Python существует две основных разновидности циклов:

циклы, повторяющиеся определенное количество раз (for, счетные циклы, counting loops); циклы, повторяющиеся до наступления определенного события (while, условные циклы, conditional loops). Цикл for замечательно работает, если мы заранее знаем, сколько повторений (итераций) нам требуется сделать.

Рассмотрим код, который распечатает 10 раз слово "Привет": for i in range(10): print('Привет')

Структура цикла for в Python выглядит так:

for название_переменной_цикла in range(количество повторений): блок кода

Двоеточие (:) в конце строки с инструкцией for сообщает интерпретатору Python, что дальше находится блок команд. В блок команд входят все строки, расположенные с отступом от строки с инструкцией for, вплоть до следующей строки без отступа.

Такая программа считывает 5 чисел и выводит на экран их квадраты вместе с поясняющей надписью. Поскольку вторая и третья строки выделены отступом, Python считает, что это тело цикла, которое выполняется 5 раз. Четвертая строка не содержит отступа, поэтому не является частью цикла и будет выполнена всего один раз, после того как цикл завершится. print('A') print('B') for i in range(5): print('C') for i in range(10): print('D') print('E')

Переменная цикла Рассмотрим для чего нужна и как работает переменная цикла i for i in range(10)

как видно из кода в Python начинается с 0 поскольку переменная цикла i увеличивается каждый раз,то ее можно использовать для отслеживания номери итерации на которой мы находимся в циклическом процессе

for i in range(10) print (i+1,'--Привет--') Имена переменных циклов Ранее говорилось, что имена переменных должны носить осмысленный характер и описывать их назначение. Однако для переменных цикла иногда делается исключения. В программировании для переменных цикла обычно используют буквы i, j, k. Бывают ситуации когда переменная цикла не используется в теле цикла. В таком случае, вместо того, чтобы давать ей имя, мы можем указать символ нижнего подчеркивания _ : for _ in range(5) print ('Python-awesome') Функция range() начение, которое мы указываем в скобках у функции range() обозначает количество итераций цикла, при этом переменная i принимает последовательно значения: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Если быть более точным, то мы говорим, что функция range(n) генерирует последовательность чисел от 0 до n-1, а цикл for последовательно перебирает эту последовательность. Перегрузка range() с двумя параметрами Если мы хотим начинать последовательность не с 0, а с какого-то другого числа, то мы можем использовать перегрузку функции range() принимающую два параметра. Например, вызов функции range(1, 5) сгенерирует последовательность чисел 1, 2, 3, 4 (будьте внимательны, правая граница не включительно). Если нам нужны числа от 1 до 5 включительно, то мы используем range(1, 6). Таким образом:

  * range(n): создает последовательность чисел 0, 1, 2, 3, ..., n - 1;
  * range(n, m): создает последовательность чисел n, n + 1, n + 2, ..., m - 2, m - 1. 

Напишем программу, которая выводит те числа из промежутка [100;999], которые оканчиваются на 7. Используя функцию range() с двумя параметрами, получаем: for i in range(100,1000): # перебираем числа от 100 до 999 if i % 10==7: #используем остаток от деления на 10,для получения последней цифры print(i) Перегрузка range() с 3 параметрами Передавая два параметра в функцию range() мы можем генерировать любую последовательность целых чисел с шагом 1. Но, что делать если нужно поменять шаг? Как быть если мы хотим сгенерировать последовательность чисел 5, 10, 15, 20, 25? В этом случае существует еще одна перегрузка функции range(), принимающая три параметра: range(n, m, k). Первый параметр задает старт последовательности, второй параметр задает стоп последовательности и третий – шаг генерации чисел.
Например, вызов функции range(1, 10, 2) создаст последовательность чисел 1, 3, 5, 7, 9, а вызов функции range(5, 30, 5) сгенерирует последовательность 5, 10, 15, 20, 25. Напишем программу, которая выводит все четные числа из промежутка [56;170].

Используя функцию range() с тремя параметрами, получаем:
![image](https://user-images.githubusercontent.com/112847166/197638919-f9a51d47-d697-4fe0-9513-b8c9db2b2e29.png)
 Отрицательный шаг генерации Если шаг генерации является положительным числом, то генерируемая последовательность будет возрастать. Мы можем указать отрицательный шаг генерации (третий параметр), что приведет к генерированию убывающей последовательности.

В случае отрицательного шага, мы должны гарантировать, что старт последовательности (первый параметр) больше чем конец последовательности (второй параметр).

Например, вызов функции range(20, 16, -1) создаст последовательность чисел 20, 19, 18, 17, а вызов функции range(20, 10, -3) сгенерирует последовательность 20, 17, 14, 11.

Напишем программу, которая отсчитывает от 5 до 1, а затем выводит текст "Взлетаем!!!"
![image](https://user-images.githubusercontent.com/112847166/197638864-15a3e152-3506-409e-a380-95edae54525f.png)

27.10.2022

Цикл while Цикл For замечательно работает,если мы заранее знаем сколько у нас повторений "Итераций" нам потребуется сделать.Но иногда нужно, чтобы цикл выполнялся до наступления некоторого события, и количество итераций в этом случае заранее оценить просто невозможно. И здесь на помощь приходит цикл while. И здесь используется цикл while. Структура цикла while в Python выглядит так:

while условие: блок кода Блок команд, который выполняется в цикле while, называется телом цикла.

Рассмотрим код, использующий цикл while, который распечатает 10 раз слово Привет:

i = 0 while i < 10: print('Привет') i += 1

Такой код можно легко заменить циклом for, поскольку мы заранее знаем сколько раз нужно выполнить тело цикла. Однако так бывает не всегда.Напишем программу, которая считывает числа и выводит их квадраты, пока не будет введено -1. При такой постановке задачи мы не можем воспользоваться циклом for, так как не знаем сколько чисел будет предшествовать числу -1.

num = int(input()) while num != -1: print('Квадрат вашего числа равен:', num * num) num = int(input()) **Важным являются два момента:

правильная инициализация переменной num;
изменение переменной num внутри цикла while.
Eсли не изменять переменную num внутри цикла, то можно получить так называемый бесконечный цикл, который будет выполняться бесконечно много раз.

Цикл for и цикл while Мы всегда можем заменить цикл for с помощью цикла while. Следующие две программы выводят числа от 0 до 100:

используем for
for i in range(101): print(i)

используем while
i = 0 while i < 101: print(i) i += 1

Считывание данных до стоп значения Часто при решении задач на цикл while, мы считываем данные, до тех пор пока пользователь не введет некоторое значение, которое называют стоп значением. Напишем программу, которая считывает числа и находит их сумму, до тех пор пока пользователь не введет слово stop:

text = input() total = 0 while text != 'stop': num = int(text) total += num text = input() print('Сумма чисел равна', total) Бесконечный цикл Всегда, кроме редких случаев, цикл while должен содержать возможность завершиться.То есть в цикле что-то должно сделать проверяемое условие ложным. Если цикл не имеет возможности завершиться, то он называется бесконечным циклом.В большинстве случаев следует избегать применения бесконечных циклов.

Пример бесконечного цикла:

i = 0 total = 0 while i < 10: total += i Так как в теле цикла не происходит изменения переменной i, то условие i < 10 остается истинным и цикл выполняется бесконечно много раз. Бесконечные циклы можно использовать в связке с оператором прерывания break.

Примечания

Примечание 1. Цикл while получил свое название из-за характера своей работы: он выполняет некую задачу до тех пор, пока условие является истинным. Слово while на английском означает как раз "пока". Примечание 2. Цикл while называют циклом с предусловием, поскольку выполнению тела цикла предшествует проверка условия (сначала проверяется условие, а уже затем выполняется тело цикла). Примечание 3. Однократное выполнение тела цикла называется итерацией цикла. Примечание 4. Цикл while может не выполниться ни одного раза. Например, следующий код:

i = -1 while i > 0: print('Hello world!')

не выведет текст, поскольку условие i > 0 ложно с самого начала. Примечание 5. Графическое представление цикла while имеет вид:

image

Примечание 6. Условие в цикле while, как и в условном операторе if, может содержать логические операции or, and, not.

While (пока ) total(общее) сщгте(cxtnxbr) При изучении целых чисел (тип данных int), мы говорили про операцию целочисленного деления // и операцию нахождения остатка от деления однного целого числа на другое%. Результатом операции n % 10 является последняя цифра числа и результатом n // 10 является число с удаленной последней цифрой

31.10.2022 Оператор прерывания цикла break break, continue, else Иногда бывает нужно прервать выполнение цикла преждевременно. Оператор break прерывает ближайший цикл for или while. Усовершенствуем программу, проверяющую число на простоту с помощью оператора break:

Как только мы встречаем делитель отличный от 1 и num, мы меняем значение сигнальной метки и прерываем цикл, поскольку дальнейшее его выполнение лишено смысла: число гарантированно не является простым. Сигнальная метка используется для того чтобы позволить циклу работать более производительно Напишем программу, использующую цикл for, которая считывает 10 чисел и суммирует их до тех пор, пока не обнаружит отрицательное число. В этом случае выполнение цикла прерывается командой break: result = 0 for i in range(10): num = int(input()) if num < 0: break result += num print(result) Оператор прерывания цикла break удобен в связке с сигнальными метками: когда после проверки некоторого условия нам нет смысла продолжать выполнение цикла. Сигнальная метка (флажок) может использоваться, когда надо чтобы одна часть программы узнала, о происходящем в другой части программы.

Бесконечные циклы В предыдущих уроках мы говорили о цикле, который не имеет возможности завершиться и назвали его бесконечным циклом. Самый простой способ создать бесконечный цикл в Python – записать следующий код: while True: print('Python awesome!') Результатом выполнения такого кода будет бесконечное количество строчек текста: Python awesome! Python awesome! . . . Python awesome! Python awesome! Python awesome! Бесконечный цикл продолжает повторяться до тех пор, пока программа не будет прервана. Изучив оператор break, мы получили механизм прерывания бесконечных циклов.

Может показаться, что бесконечные циклы лишены смысла, однако это не совсем так. Например, вы можете написать программу, которая запускается и работает, постоянно принимая запросы на обслуживание. Программный код такой программы может выглядеть так: while True: query = get_new_query() # получаем новый запрос на обработку query.process() # обрабатываем запрос Оператор continue Другая стандартная идиома циклов — пропуск отдельных элементов при переборе. Оператор continue позволяет перейти к следующей итерации цикла for или while до завершения всех команд в теле цикла. Напишем программу, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78. for i in range(1, 101): if i == 7 or i == 17 or i == 29 or i == 78: continue # переходим на следующую итерацию print(i) image

Ревью кода Ревью кода – проверка исходного кода программы с целью обнаружения и исправления ошибок и неточностей, которые остались незамеченными при начальной разработке. В процессе ревью кода могут быть исправлены: фактические ошибки; производительность кода; читабельность кода и ошибки форматирования кода. Целью ревью кода является улучшение качества программного кода и совершенствование навыков программиста. Как правило ревью кода выполняет программист с большим опытом. Фактические ошибки К фактическим ошибкам в коде относятся ошибки из-за которых код может работать неверно. По сути, это ошибки относящиеся к алгоритму, который используется в программе для решения задачи.

Среди частых фактических ошибок встречаются:

отсутствие начальной инициализации переменной;
неправильная начальная инициализация переменной;
отсутствие отступа (в Python блоки кода выделяются отступами);
неправильные числовые граничные значения, например при использовании функции range();
неправильные граничные сравнения (путаница с >, >= или <, <=);
путаница логических операций or и and и т.д.
Производительность кода Под производительностью кода в простейшем случае можно подразумевать то, сколько времени программа тратит на решение задачи. При написании программы, программист должен думать над тем, сколько времени в худшем случае потребуется его программе для решения задачи. Читабельность кода Следует помнить, что наш код должен легко читаться другими программистами. Чтобы этого достичь, следует придерживаться стандарта PEP 8. Обращайте внимание на следующие моменты:

отступы и пробелы: используйте 4 пробела на один уровень отступа и никогда не смешивайте символы табуляции и пробелы; названия переменных: используйте говорящие названия для переменных (total, counter, product) и следуйте стилю lower_case_with_underscores (слова из маленьких букв с подчеркиваниями);
пустые строки: дополнительные отступы пустыми строками могут быть изредка полезны для выделения группы логически связанных частей программы: инициализация переменных, основной алгоритм, завершающая проверка и т.д.;
комментарии: комментарии должны являться законченными предложениями. И помните, комментарии, которые противоречат коду, хуже, чем отсутствие комментариев. Всегда исправляйте комментарии, если меняете код! Вложенные циклы Вложенный цикл расположен в еще одном цикле. Часы служат хорошим примером работы вложенного цикла. Секундная, минутная и часовая стрелки вращаются вокруг циферблата.Часовая стрелка смещается всего на 1 шаг для каждых 60 шагов минутной стрелки. И секундная стрелка должна сделать 60 шагов для 1 шага минутной стрелки. Это означает, что для каждого полного оборота часовой стрелки (12 шагов), минутная стрелка делает 720 шагов. Рассмотрим цикл, который частично моделирует электронные часы. Он показывает секунды от 0 до 59: for seconds in range(60): print(seconds)
Можно добавить переменную minutes и вложить цикл написанный выше внутрь еще одного цикла, который повторяется 60 раз: for minutes in range(60): for seconds in range(60): print(minutes, ':', seconds)

02.11.2022 Вложенные циклы Вложенный цикл расположен в еще одном цикле. Часы служат хорошим примером работы вложенного цикла. Секундная, минутная и часовая стрелки вращаются вокруг циферблата.Часовая стрелка смещается всего на 1 шаг для каждых 60 шагов минутной стрелки. И секундная стрелка должна сделать 60 шагов для 1 шага минутной стрелки. Это означает, что для каждого полного оборота часовой стрелки (12 шагов), минутная стрелка делает 720 шагов. Самый внутренний цикл сделает 60 итераций для каждой итерации среднего цикла. Средний цикл сделает 60 итераций для каждой итерации самого внешнего цикла. Когда самый внешний цикл сделает 24 итерации, средний сделает

24⋅60=1440 итераций, и самый внутренний цикл сделает

24 ⋅60⋅60=86400 итераций!

Пример имитационной модели часов подводит нас к нескольким моментам, имеющим отношение к вложенным циклам: вложенный цикл выполняет все свои итерации для каждой отдельной итерации внешнего цикла; вложенные циклы завершают свои итерации быстрее, чем внешние циклы; для того, чтобы получить общее количество итераций вложенного цикла, надо перемножить количество итераций всех циклов. Мы можем вкладывать друг в друга циклы как for, так и while. Операторы break и continue во вложенных циклах Оператор break выполняет прерывание ближайшего цикла в котором он расположен. Аналогично, оператор continue осуществляет переход на следующую итерацию ближайшего цикла. Рассмотрим программный код: for i in range(3): for j in range(3): print(i, j) Результатом его выполнения будут 9 строк: Примеры решения задач Один интересный способ узнать о работе вложенных циклов состоит в их использовании для вывода на экран комбинаций символов. Давайте взглянем на один простой пример. Предположим, что мы хотим напечатать на экране звездочки в виде прямоугольной таблицы: Таблица состоящая из звездочек состоит из 8 строк и 6 столбцов. Приведенный ниже фрагмент кода можно использовать для вывода одной строки звездочек: for i in range(6): print ( '', end='') Для того чтобы завершить весь вывод таблицы звездочек, нам нужно выполнить этот цикл восемь раз. Мы можем поместить этот цикл в еще один цикл, который делает восемь итераций, как показано ниже: for i in range(8): for j in range(6): print('', end='') print() Внешний цикл делает восемь итераций. Во время каждой итерации этого цикла внутренний цикл делает 6 итераций. (Обратите внимание, что в строке 4 после того, как все строки были напечатаны, мы вызываем функцию print(). Мы должны это сделать, чтобы в конце каждой строки продвинуть экранный курсор на следующую строку. Без этой инструкции все звездочки будут напечатаны на экране в виде одной длинной строки.) Давайте рассмотрим еще один пример. Предположим, что вы хотите напечатать звездочки в комбинации, которая похожа на приведенный ниже звездный треугольник:

03.11.2022 Использование вложенных циклов при решении уравнений Вложенные циклы можно использовать для решения уравнений с несколькими переменными. Зная, что решения (корни) уравнения являются натуральными (целыми) числами, несложно написать программу, содержащую вложенный цикл и перебирающую все возможные значения переменных.

Строки. Строки в Python используются когда надо работать с текстовыми данными. Создание строки. Для создания строк, мы используем парные кавычки '' или "":

s1 = 'Python' s2 = "Pascal"

Считывание строки. Для считывания текстовых данных в строковую переменную, мы используем функцию input():

s = input() # считали текст num = int(input()) # считали текст и преобразовали его в целое число

Пустая строка. Для создания пустой строки, мы пишем s = '' или s = "". Пустая строка – это аналог числа 0. Длина строки. Для определения длины строки (количества символов), мы используем встроенную функцию len():

s = 'Hello' n = len(s) # значение переменной равно 5 print(n)

Конкатенация и умножение на число. Операторы + и * можно использовать для строк. Оператор + сцепляет две и более строк. Это называется конкатенацией строк. Оператор * повторяет строку указанное количество раз. !image Оператор принадлежности in. С помощью оператора in, мы можем проверять, находится ли одна строка в составе другой. То есть, является ли одна строка подстрокой другой: s = 'All you need is love' if 'love' in s: print('❤️') else: print('💔') Так как строка s содержит подстроку 'love', то будет выведен смайлик ❤️. В Python можно использовать смайлики emoji👍 image

Таким образом, получаем !image Частая ошибка у начинающих программистов — обращение по несуществующему индексу в строке. Например, если s = 'Python', и мы попытаемся обратится к s[17], то мы получим ошибку: IndexError: string index out of range Ошибка возникает, поскольку строка содержит всего 6 символов. Обратите внимание: если длина строки s равна len(s), то при положительной нумерации слева направо, последний элемент имеет индекс равный len(s) - 1, а при отрицательной индексации справа налево, первый элемент имеет индекс равный -len(s). Итерирование строк Очень часто нужно просканировать всю строку целиком, обрабатывая каждый ее символ. Для этого удобно использовать цикл for. Напишем программу, которая выводит каждый символ строки на отдельной строке: s = 'abcdef' for i in range(len(s)): print(s[i]) Результатом выполнения такой программы будут строки: a b c d e f Мы передаем в функцию range() длину строки len(s). В нашем случае длина строки s, равна 6. Таким образом, вызов функции range(len(s)) имеет вид range(6) и переменная цикла i последовательно перебирает все значения от 0 до 5. Это означает, что выражение s[i] последовательно вернет все символы строки s. Такой способ итерации строки удобен, когда нам нужен не только сам элемент s[i], но и его индекс i.

Срезы строк В предыдущем уроке мы научились работать с конкретными символами строки с помощью индексов []. Иногда нужно бывает работать с целыми частями строки, в таком случае мы используем срезы (slices). Срезы похожи на комбинацию индексации и функции range(). Рассмотрим строку s = 'abcdefghij'.

При построении среза s[x:y] первое число – это то место, где начинается срез (включительно), а второе – это место, где заканчивается срез (невключительно). Разрезая строки, мы создаем подстроку, которая по сути является строкой внутри другой строки.

image image image image image image

Методы и функции Мы уже знакомы с некоторыми встроенными функциями: min(),max(),len(),int(),float() и т.д. Метод — специализированная функция, тесно связанная с объектом. Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается для определенного объекта и “знает” о своем целевом объекте во время выполнения.

Таким образом: метод — функция, применяемая к объекту. В данном случае к строке. Метод вызывается в виде имя_объекта.имя_метода(параметры). Например, s.find('e') — это применение к строке s метода find с одним параметром 'e'.

Методы строкового типа данных можно разделить на три группы:

Конвертация регистра; Поиск и замена; Классификация символов.

Конвертация регистра Методы в этой группе выполняют преобразование регистра для строк.

Метод capitalize()

Метод capitalize() возвращает копию строки s, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр. Результатом выполнения следующего кода: s = 'foO BaR BAZ quX' print(s.capitalize()) будет: Foo bar baz qux

Символы, не являющиеся буквами алфавита, остаются неизменными. Результатом выполнения следующего кода: s = 'foo123#BAR#.' print(s.capitalize()) будет: Foo123#bar#. Метод swapcase() Метод swapcase() возвращает копию строки s, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот. Результатом выполнения следующего кода: s = 'FOO Bar 123 baz qUX' print(s.swapcase()) будет: foo bAR 123 BAZ Qux Метод title() Метод title() возвращает копию строки s, в которой первый символ каждого слова переводится в верхний регистр. Результатом выполнения следующего кода: s = 'the sun also rises' print(s.title()) будет: The Sun Also Rises Этот метод использует довольно простой алгоритм: он не пытается различить важные и неважные слова и не обрабатывает аббревиатуры и апострофы. Результатом выполнения следующего кода: s = "what's happened to ted's IBM stock?" print(s.title()) будет: What'S Happened To Ted'S Ibm Stock?

Метод lower()

Метод lower() возвращает копию строки s, в которой все символы имеют нижний регистр. Результатом выполнения следующего кода: s = 'FOO Bar 123 baz qUX' print(s.lower()) будет: foo bar 123 baz qux

Метод upper()

Метод upper() возвращает копию строки s, в которой все символы имеют верхний регистр. Результатом выполнения следующего кода: s = 'FOO Bar 123 baz qUX' print(s.upper()) будет: FOO BAR 123 BAZ QUX

Поиск и замена Методы поиска и замены строк внутри других строк. Каждый метод в этой группе поддерживает необязательные аргументы 'start' и 'end'. Как и в строковых срезах действие метода ограничено частью исходной строки, начинающейся с позиции символа 'start' и продолжающейся вплоть до позиции символа 'end', но не включающей ее. Если параметр 'start' указан, а параметр 'end' нет, то метод применяется к части исходной строки от 'start' до конца строки. Если параметры не заданы, то подразумевается, что 'start' = 0 , 'end' = len(s).

Метод count()

Метод count('sub', 'start', 'end') считает количество непересекающихся вхождений подстроки 'sub' в исходную строку s. Результатом выполнения следующего кода: s = 'foo goo moo' print(s.count('oo')) print(s.count('oo', 0, 8)) # подсчет с 0 по 7 символ будет: 3 2

Метод startswith()

Метод startswith('suffix', 'start', 'end') определяет начинается ли исходная строка s подстрокой 'suffix'. Если исходная строка начинается с подстроки 'suffix',метод возвращает значение True, а если нет, то False. Результатом выполнения следующего кода: s = 'foobar' print(s.startswith('foo')) print(s.startswith('baz')) будет: True False

Метод endswith()

Метод endswith('suffix', 'start', 'end') определяет оканчивается ли исходная строка s подстрокой 'suffix'. Метод возвращает значение True если исходная строка оканчивается на подстроку 'suffix' и False в противном случае. Результатом выполнения следующего кода: s = 'foobar' print(s.endswith('bar')) print(s.endswith('baz')) будет: True False

Методы find(), rfind()

Метод find('sub', 'start', 'end') находит индекс первого вхождения подстроки 'sub' в исходной строке s. Если строка s не содержит подстроки 'sub', то метод возвращает значение -1. Мы можем использовать данный метод наравне с оператором in для проверки: содержит ли заданная строка некоторую подстроку или нет. Результатом выполнения следующего кода: s = 'foo bar foo baz foo qux' print(s.find('foo')) print(s.find('bar')) print(s.find('qu')) print(s.find('python')) будет: 0 4 20 -1 Метод rfind('sub', 'start', 'end') идентичен методу find('sub', 'start', 'end'), за тем исключением, что он ищет первое вхождение подстроки 'sub' начиная с конца строки s.

Методы index(), rindex()

Метод index('sub', 'start', 'end') идентичен методу find('sub', 'start', 'end'), за тем исключением, что он вызывает ошибку ValueError: substring not found во время выполнения программы, если подстрока 'sub' не найдена. Метод rindex('sub', 'start', 'end') идентичен методу index('sub', 'start', 'end'), за тем исключением, что он ищет первое вхождение подстроки 'sub' начиная с конца строки s. Методы find() и rfind() являются более безопасными чем index() и rindex(), так как не приводят к возникновению ошибки во время выполнения программы.

Метод strip() Метод strip() возвращает копию строки s у которой удалены все пробелы стоящие в начале и конце строки. Результатом выполнения следующего кода: s = ' foo bar foo baz foo qux ' print(s.strip()) будет: foo bar foo baz foo qux

Метод lstrip()

Метод lstrip() возвращает копию строки s у которой удалены все пробелы стоящие в начале строки. Результатом выполнения следующего кода: s = ' foo bar foo baz foo qux ' print(s.lstrip()) будет: foo bar foo baz foo qux⎵ ⎵ ⎵ ⎵ ⎵ ⎵

Метод rstrip()

Метод rstrip() возвращает копию строки s у которой удалены все пробелы стоящие в конце строки. Результатом выполнения следующего кода: s = ' foo bar foo baz foo qux ' print(s.rstrip()) будет: ⎵ ⎵ ⎵ ⎵ ⎵ ⎵foo bar foo baz foo qux

Методы strip(), lstrip(), rstrip() могут принимать на вход опциональный аргумент'chars'. Необязательный аргумент 'chars'– это строка, которая определяет набор символов для удаления.

Метод replace()

Метод replace('old', 'new') возвращает копию s со всеми вхождениями подстроки 'old', замененными на 'new'. Результатом выполнения следующего кода: s = 'foo bar foo baz foo qux' print(s.replace('foo', 'grault')) будет: grault bar grault baz grault qux

Метод replace() может принимать опциональный третий аргумент 'count', который определяет количество замен. Результатом выполнения следующего кода: s = 'foo bar foo baz foo qux' print(s.replace('foo', 'grault', 2)) будет: grault bar grault baz foo qux

Представление строк в памяти компьютера, ASCII и Unicode Любой набор данных в оперативной памяти (конспект информации представленной по данной ссылке) компьютера должен храниться в виде двоичного числа. Это относится и к строкам, которые состоят из символов (буквы, знаки препинания и т.д.). Когда символ сохраняется в памяти, он сначала преобразуется в цифровой код. И затем этот цифровой код сохраняется в памяти как двоичное число. За прошедшие годы для представления символов в памяти компьютера были разработаны различные схемы кодирования. Исторически самой важной из этих схем кодирования является схема кодирования ASCII (American Standard Code for Information Interchange – американский стандартный код обмена информацией).

Таблица символов ASCII

ASCII представляет собой набор из 128 цифровых кодов, которые обозначают английские буквы, различные знаки препинания и другие символы. Например, код ASCII для прописной английской буквы «А» (латинской) равняется 65. Когда на компьютерной клавиатуре вы набираете букву «А» в верхнем регистре, в памяти сохраняется число 65 (как двоичное число, разумеется).

В начале 1990-х годов был разработан набор символов Юникода (Unicode). Это широкая схема кодирования, совместимая с ASCII, которая может также представлять символы многих языков мира. Сегодня Юникод быстро становится стандартным набором символов, используемым в компьютерной индустрии.

Таблица символов Unicode

Таблица символов Юникод представляет собой набор цифровых символов, которые включают в себя знаки почти всех письменных языков мира. Стандарт предложен в 1991 году некоммерческой организацией «Консорциум Юникода». Применение этого стандарта позволяет закодировать очень большое число символов из разных систем письменности: в документах, закодированных по стандарту Юникод, могут соседствовать китайские иероглифы, математические символы, буквы греческого алфавита, латиницы и кириллицы, символы музыкальной нотной нотации. Стандарт состоит из двух основных частей: универсального набора символов и семейства кодировок (Unicode transformation format, UTF). Универсальный набор символов перечисляет допустимые по стандарту Юникод символы и присваивает каждому символу код в виде неотрицательного целого числа. Семейство кодировок определяет способы преобразования кодов символов для хранения на компьютере и передачи. В Юникод все время добавляются новые символы, а сам размер этой таблицы не ограничен и будет только расти, поэтому сейчас при хранении в памяти одного юникод-символа может потребоваться от 1 до 8 байт. Отсутствие ограничений привело к тому, что стали появляться символы на все случаи жизни.

В Python строки хранятся в виде последовательности юникод символов.

Примечания Примечание 1. Официальный сайт таблицы символов Unicode. Примечание 2. Юникод — это не кодировка. Это именно таблица символов. То, как символы с соответствующими кодами будут храниться в памяти компьютера, зависит от конкретной кодировки, базирующейся на Юникоде, например UTF-8. Про отличие таблицы символов Unicode от кодировки UTF-8 можно почитать тут. Примечание 3. Первые 128 кодов таблицы символов Unicode совпадают с ASCII.

Функция ord

Функция ord позволяет определить код некоторого символа в таблице символов Unicode. Аргументом данной функции является одиночный символ. Результатом выполнения следующего кода: num1 = ord('A') num2 = ord('B') num3 = ord('a') print(num1, num2, num3) будет: 65 66 97 Обратите внимание, что функция ord принимает именно одиночный символ. Если попытаться передать строку, содержащую более одного символа: num = ord('Abc') print(num) мы получим ошибку времени выполнения: TypeError: ord() expected a character, but string of length 3 found

Функция chr

Функция chr позволяет определить по коду символа сам символ. Аргументом данной функции является численный код. Результатом выполнения следующего кода: chr1 = chr(65) chr2 = chr(75) chr3 = chr(110) print(chr1, chr2, chr3) будет: A K n

Функции ord и chr часто работают в паре. Мы можем использовать следующий код для вывода всех заглавных букв английского алфавита: for i in range(26): print(chr(ord('A') + i)) Вызов функции ord('A') возвращает код символа «A», который равен 65. Далее на каждой итерации цикла, к данному коду прибавляется значение переменной i = 0, 1, 2, ..., 25, а затем полученный код преобразуется в символ с помощью вызова функции chr.

Примечание. Функции ord и chr являются взаимнообратными. Для них выполнены равенства: chr(ord('A')) = 'A', ord(chr(65)) = 65.

Списки В предыдущих уроках мы работали с последовательностями чисел, символов, строк, но не сохраняли всю последовательность в памяти компьютера, а обрабатывали ее поэлементно, считывая раз за разом новый элемент. Однако во многих задачах требуется сохранять всю последовательность. Например, классическая задача сортировки (упорядочения) некоторой последовательности требует сохранения всех данных в памяти компьютера. Увы, не сохранив, их невозможно отсортировать. И тут на помощь приходит структура данных, которая в большинстве языков программирования называется массивом. В Python она называется списком. Структура данных (data structure) — программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных. Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке.

Создание списка Чтобы создать список, нужно перечислить его элементы через запятую в квадратных скобках: numbers = [2, 4, 6, 8, 10] languages = ['Python', 'C#', 'C++', 'Java']

Список numbers состоит из 5 элементов, и каждый из них — целое число. numbers[0] == 2; numbers[1] == 4; numbers[2] == 6; numbers[3] == 8; numbers[4] == 10.

Список languages состоит из 4 элементов, каждый из которых — строка. languages[0] == 'Python'; languages[1] == 'C#'; languages[2] == 'C++'; languages[3] == 'Java'.

Значения, заключенные в квадратные скобки и отделенные запятыми, называются элементами списка. Список может содержать значения разных типов данных: info = ['Timur', 1992, 61.5] Список info содержит строковое значение, целое число и число с плавающей точкой. info[0] == 'Timur'; info[1] == 1992; info[2] == 61.5. Обычно элементы списка содержат данные одного типа и на практике редко приходится создавать списки содержащие элементы разных типов данных.

Пустой список Создать пустой список можно двумя способами: Использовать пустые квадратные скобки []; Использовать встроенную функцию, которая называется list. Следующие две строки кода создают пустой список: mylist = [] # пустой список mylist = list() # пустой список

Вывод списка Для вывода всего списка можно применить функцию print(): numbers = [2, 4, 6, 8, 10] languages = ['Python', 'C#', 'C++', 'Java'] print(numbers) print(languages) Функция print() выводит на экран элементы списка, в квадратных скобках, разделенные запятыми: [2, 4, 6, 8, 10] ['Python', 'C#', 'C++', 'Java']

Встроенная функция list Python имеет встроенную функцию list(), которая помимо создания пустого списка может преобразовывать некоторые типы объектов в списки. Например, мы знаем, что функция range() создает последовательность целых чисел в заданном диапазоне. Для преобразования этой последовательности в список, мы пишем следующий код: numbers = list(range(5)) !! Во время исполнения этого кода происходит следующее: Вызывается функция range(), в которую в качестве аргумента передается число 5; Эта функция возвращает последовательность чисел 0, 1, 2, 3, 4; Последовательность чисел 0, 1, 2, 3, 4 передается в качестве аргумента в функцию list(); Функция list() возвращает список [0, 1, 2, 3, 4]; Список [0, 1, 2, 3, 4] присваивается переменной numbers.

Вот еще один пример: even_numbers = list(range(0, 10, 2)) # список содержит четные числа 0, 2, 4, 6, 8 odd_numbers = list(range(1, 10, 2)) # список содержит нечетные числа 1, 3, 5, 7, 9

Точно также с помощью функции list() мы можем создать список из символов строки. Для преобразования строки в список мы пишем следующий код: s = 'abcde' chars = list(s) # список содержит символы 'a', 'b', 'c', 'd', 'e' Во время исполнения этого кода происходит следующее: Вызывается функция list(), в которую в качестве аргумента передается строка 'abcde'; Функция list() возвращает список ['a', 'b', 'c', 'd', 'e']; Список ['a', 'b', 'c', 'd', 'e'] присваивается переменной chars. Примечание 1. Как уже было сказано, списки в Python аналогичны массивам в других языках программирования. Однако разница между списками и массивами все же существует. Элементы массива всегда имеют одинаковый тип данных и располагаются в памяти компьютера непрерывным блоком, а элементы списка могут быть разбросаны по памяти как угодно и могут иметь разный тип данных. Примечание 2. Обратите внимание, при выводе содержимого списка с помощью функции print(), все строковые элементы списка обрамляются одинарными кавычками. Если требуется осуществить вывод в двойных кавычках, нужно самостоятельно писать код вывода.

Функция len() Длиной списка называется количество его элементов. Для того, чтобы посчитать длину списка мы используем встроенную функцию len() (от слова length – длина). Следующий программный код: numbers = [2, 4, 6, 8, 10] languages = ['Python', 'C#', 'C++', 'Java']

print(len(numbers)) # выводим длину списка numbers print(len(languages)) # выводим длину списка languages

print(len(['apple', 'banana', 'cherry'])) # выводим длину списка, состоящего из 3 элементов

Оператор принадлежности in Оператор in позволяет проверить, содержит ли список некоторый элемент. Рассмотрим следующий код: numbers = [2, 4, 6, 8, 10] if 2 in numbers: print('Список numbers содержит число 2') else: print('Список numbers не содержит число 2') Такой код проверяет, содержит ли список numbers число 2 и выводит соответствующий текст: Список numbers содержит число 2 Мы можем использовать оператор in вместе с логическим оператором not. Например numbers = [2, 4, 6, 8, 10] if 0 not in numbers: print('Список numbers не содержит нулей')

Индексация При работе со строками мы использовали индексацию, то есть обращение к конкретному символу строки по его индексу. Аналогично, можно индексировать и списки. Для индексации списков в Python используются квадратные скобки [], в которых указывается индекс (номер) нужного элемента в списке: Пусть numbers = [2, 4, 6, 8, 10]. Таблица ниже, показывает как работает индексация:

image

Так же, как и в строках, для нумерации с конца разрешены отрицательные индексы. image Как и в строках, попытка обратиться к элементу списка по несуществующему индексу: print(numbers[17]) вызовет ошибку: IndexError: index out of range

Срезы Рассмотрим список numbers = [2, 4, 6, 8, 10]. С помощью среза мы можем получить несколько элементов списка, создав диапазон индексов разделенных двоеточием numbers[x:y]. Следующий программный код: print(numbers[1:3]) print(numbers[2:5]) выводит: [4, 6] [6, 8, 10] При построении среза numbers[x:y] первое число – это то место, где начинается срез (включительно), а второе – это место, где заканчивается срез (невключительно). Разрезая списки, мы создаем новые списки, по сути, подсписки исходного. При использовании срезов со списками мы также можем опускать второй параметр в срезе numbers[x:] (но поставить двоеточие), тогда срез берется до конца списка. Аналогично если опустить первый параметр numbers[:y], то можно взять срез от начала списка.

Срез numbers[:] возвращает копию исходного списка. Как и в строках, мы можем использовать отрицательные индексы в срезах списков.

Использование срезов для изменения элементов в заданном диапазоне Для изменения целого диапазона элементов списка можно использовать срезы. Например, если мы хотим перевести на русский язык названия фруктов 'banana', 'cherry', 'kiwi', то это можно сделать с помощью среза. Следующий программный код: fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango'] fruits[2:5] = ['банан', 'вишня', 'киви'] print(fruits) выводит: ['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango']

**Операция конкатенации + и умножения на число * ** Мы можем применять операторы + и * для списков подобно тому как мы это делали со строками. Следующий программный код: print([1, 2, 3, 4] + [5, 6, 7, 8]) print([7, 8] * 3) print([0] * 10) выводит: [1, 2, 3, 4, 5, 6, 7, 8] [7, 8, 7, 8, 7, 8] [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

Для генерации списков, состоящих строго из повторяющихся элементов, умножение на число — самый короткий и правильный метод. Мы также можем использовать расширенные операторы += и *= при работе со списками. Следующий программный код: a = [1, 2, 3, 4] b = [7, 8] a += b # добавляем к списку a список b b *= 5 # повторяем список b 5 раз print(a) print(b)

выводит: [1, 2, 3, 4, 7, 8] [7, 8, 7, 8, 7, 8, 7, 8, 7, 8]

Встроенные функции sum(), min(), max()

Встроенная функция sum() принимает в качестве параметра список чисел и вычисляет сумму его элементов. Следующий программный код: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print('Сумма всех элементов списка =', sum(numbers)) выводит: Сумма всех элементов списка = 55 Встроенные функции min() и max() принимают в качестве параметра список и находят минимальный и максимальный элементы соответственно. Следующий программный код: numbers = [3, 4, 10, 3333, 12, -7, -5, 4] print('Минимальный элемент =', min(numbers)) print('Максимальный элемент =', max(numbers)) выводит: Минимальный элемент = -7 Максимальный элемент = 3333

Отличие списков от строк Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — неизменяемые объекты, а списки – изменяемые. Следующий программный код: s = 'abcdefg' s[1] = 'x' # пытаемся изменить 2 символ (по индексу 1) строки приводит к ошибке: object does not support item assignment

Следующий программный код: numbers = [1, 2, 3, 4, 5, 6, 7] numbers[1] = 101 # изменяем 2 элемент (по индексу 1) списка print(numbers) выводит: [1, 101, 3, 4, 5, 6, 7]

ВАЖНО: изменять отдельные символы строк нельзя, однако можно изменять отдельные элементы списков. Для этого используем индексатор и оператор присваивания.

Следующий программный код: numbers = [1, 2, 3, 4, 5, 6, 7] numbers[1] = 101 # изменяем 2 элемент (по индексу 1) списка print(numbers) выводит: [1, 101, 3, 4, 5, 6, 7] ВАЖНО: изменять отдельные символы строк нельзя, однако можно изменять отдельные элементы списков. Для этого используем индексатор и оператор присваивания. Добавление элементов Метод append() Для добавления нового элемента в конец списка используется метод append(). Следующий программный код: numbers = [1, 1, 2, 3, 5, 8, 13] # создаем список numbers.append(21) # добавляем число 21 в конец списка numbers.append(34) # добавляем число 34 в конец списка print(numbers)

выведет: [1, 1, 2, 3, 5, 8, 13, 21, 34]

Обратите внимание, для того чСледующий программный код: numbers = [] # создаем пустой список numbers.append(1) numbers.append(2) numbers.append(3) print(numbers)

выведет: [1, 2, 3] тобы использовать метод append(), нужно, чтобы список был создан, при этом он может быть пустым. Важно: мы не можем использовать индексаторы для установки значений элементов списка, если список пустой. Следующий программный код: numbers = [] # создаем пустой список numbers[0] = 1 numbers[1] = 2 numbers[2] = 3 print(numbers) приводит к ошибке: IndexError: list assignment index out of range Метод extend() Можно также расширить список другим списком, путем вызова метода extend(). Следующий программный код: numbers = [0, 2, 4, 6, 8, 10] odds = [1, 3, 5, 7] numbers.extend(odds) print(numbers)

Метод extend() как бы расширяет один список, добавляя к нему элементы другого списка. Отличие между методами append() и extend() проявляется при добавлении строки к списку. Следующий программный код: words1 = ['iq option', 'stepik', 'beegeek'] words2 = ['iq option', 'stepik', 'beegeek'] words1.append('python') words2.extend('python') print(words1) print(words2) Метод append() добавляет строку 'python' целиком к списку, а метод extend() разбивает строку 'python' на символы 'p', 'y', 't', 'h', 'o', 'n' и их добавляет в качестве элементов списка. Удаление элементов С помощью оператора del можно удалять элементы списка по определенному индексу. Следующий программный код: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] del numbers[5] # удаляем элемент имеющий индекс 5 print(numbers) выведет: [1, 2, 3, 4, 5, 7, 8, 9] Элемент под указанным индексом удаляется, а список перестраивается. Обратите внимание на синтаксис удаления, так как он отличается от обычного вызова метода. При удалении элементов не надо передавать аргумент внутри круглых скобок. Оператор del работает и со срезами: мы можем удалить целый диапазон элементов списка. Следующий программный код: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] del numbers[2:7] # удаляем элементы с 2 по 6 включительно print(numbers) выведет: [1, 2, 8, 9] Мы можем удалить все элементы на четных позициях (0, 2, 4, ...) исходного списка. Следующий программный код: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] del numbers[::2] print(numbers) выведет: [2, 4, 6, 8] Регулярные выражения в Python Регулярное выражение (Regular Expression, RegEx) — это мощный, гибкий и эффективный инструмент для сопоставления текста на основе заранее определенного шаблона. Т.е. регулярные выражения позволяют найти строки или наборы строк в тексте, используя специализированный синтаксис, с помощью которого описывается шаблон для поиска. Универсальные шаблоны регулярных выражений напоминают миниатюрный язык программирования, который предназначен для описания и разбора текста. Регулярное выражение — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать много разных строчек. Термин «Регулярные выражения» является переводом английского словосочетания «Regular expressions». Перевод не очень точно отражает смысл, правильнее было бы «шаблонные выражения». Регулярное выражение, или коротко «регулярка», состоит из обычных символов и специальных командных последовательностей. Например, \d задаёт любую цифру, а \d+ — задает любую последовательность из одной или более цифр. Примеры регулярных выражений import re

#Проверка на почту list = ["taвсыrdv69@yanввdex.ru", "tardv69@yandex.ru", "t@yandex.ru"] for test in list: x = re.search("[a-zA-Z0-9]@[a-zA-Z0-9]+.ru", test) if x: print("YES! We have email!", test) else: print("No email", test) import re

phones=['+79159171517','+79108051624','+89102626450'] for phone in phones: x=re.search('^+?[7][0-9]{10}$',phone) if x: print('YES! We have phone') else: print('No phone') Давайте попробуем понять, почему нам следует использовать регулярные выражения для работы с текстом? Вот несколько сценариев для работы с RegEx в Python: Data Mining: регулярное выражение — лучший инструмент для интеллектуального анализа данных. Он эффективно идентифицирует текст (строку, подстроку) в большом объеме текста, проверяя его по заранее заданному шаблону. Некоторые распространенные сценарии — определение адреса электронной почты, URL-адреса или телефона из большого объема текста. Data Validation (Проверка данных): регулярное выражение подходит также для таких задач, как проверка данных. Он может включать в себя широкий спектр процессов проверки путем определения различных наборов шаблонов. Вот несколько примеров: проверка номеров телефонов, электронной почты и т.д. одуль Re (import re) — операции с регулярными выражениями Python имеет встроенный пакет с именем re, который можно использовать для работы с регулярными выражениями. Этот модуль предоставляет операции сопоставления регулярных выражений в Python, аналогичные тем, которые имеются в Perl. Основная функция модуля re — предложить поиск, в котором используются регулярное выражение и строка. Здесь он либо возвращает первое совпадение, либо ничего. Модуль re вызывает исключение re.error, если ошибка возникает при компиляции или использовании регулярного выражения. Команда для импорта модуля re: import re одуль Re (import re) — операции с регулярными выражениями Python имеет встроенный пакет с именем re, который можно использовать для работы с регулярными выражениями. Этот модуль предоставляет операции сопоставления регулярных выражений в Python, аналогичные тем, которые имеются в Perl. Основная функция модуля re — предложить поиск, в котором используются регулярное выражение и строка. Здесь он либо возвращает первое совпадение, либо ничего. Модуль re вызывает исключение re.error, если ошибка возникает при компиляции или использовании регулярного выражения. Команда для импорта модуля re: import re В данном коде я добавил еще 1 переменную и расширение .com В данном коде я добавил,чтобы можно было определить любой номер телефона.Можно вводить ‘-’ , ’()’ , ’Пробелы’












































